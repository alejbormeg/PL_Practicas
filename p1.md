# Diseño del lenguaje
El lenguaje que describimos a continuación **(BBAAC)** está basado en la sintaxis de **C**, con palabras reservadas en **inglés**, a cuyos tipos de datos primitivos añadimos la estructura **lista**, los subprogramas son **funciones** y además de las estructuras de control básicas incluimos la estructura **repeat-until**


```BNF
<Programa>  ::= <Cabecera_programa> <bloque>

<bloque>    ::= {
                <Declar_de_variables_locales>
                <Declar_de_subprogs>
                <Sentencias>
                }

<Declar_de_subprogs> ::= <Declar_de_subprogs> <Declar_subprog> |

<Declar_subprog> ::= <Cabecera_subprograma> <bloque>

<Declar_de_variables_locales> ::=   var {
                                    <Variables_locales>
                                    }
                                    |

<Cabecera_programa> ::= main (<parametros>)
<parametros> ::= <variables> 

ESTO YA ESTÁ HECHO:
<Inicio_de_bloque> ::= En C: {
En Pascal: begin
<Fin_de_bloque> ::= En C: }
En Pascal: end

<Variables_locales> ::= <Variables_locales> <Cuerpo_declar_variables>
                        | <Cuerpo_declar_variables>


<Cuerpo_declar_variables> ::= <tipo> <variables> ;

<tipo> ::= <primitivo> | <estructura>
<primitivo> ::= bool | char | float | int | string
<estructura> ::= list of <primitivo>

<variables> ::= <identificador>, <variables> | <identificador>
<identificador> ::= <letra> | <letra> <letra_o_digito>
<letra_o_digito> ::= <letra_o_digito> <letra> | <letra_o_digito> <digito> | <letra> | <digito>

<letra> ::= _ | a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z |
            A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
<digito> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9


<Cabecera_subprog> ::= <tipo> <identificador> (<parametros>) | void <identificador> (<parametros>)

<Sentencias> ::= <Sentencias> <Sentencia> | <Sentencia>

<Sentencia> ::=   <bloque>
                | <sentencia_asignacion>
                | <sentencia_if>
                | <sentencia_while>
                | <sentencia_entrada>
                | <sentencia_salida>
                | <sentencia_return>
                | <sentencia_repeat_until>


<sentencia_asignacion> ::= <identificador> = <expresion>

<sentencia_if> ::= if (<expresion>) <bloque> <sentencia_else>
<sentencia_else> ::= else <bloque> | elif (<expresion>) <bloque> | elif (<expresion>) <bloque> <sentencia_else> |

<sentencia_while> ::= while (<expresion>) <bloque>

<sentencia_entrada> ::= input(<id>) ;

<sentencia_salida> ::= output(<expresion>) ;

<sentencia_return> :: return <expresion> ;

<sentencia_repeat_until> ::= repeat <bloque> until (<expresion>) ;

<expresion> ::= ( <expresion> )
                | <op_unario> <expresion>
                | <expresion> <op_binario> <expresion>
                | <identificador>
                | <constante>
                | <funcion>

<op_unario> ::= | //
                | not
                | -
                | ++
                | --
                | get_back                          # Último elemento de una lista
                | get_front                         # Primer elemento de una lista
                | pop_back                          # Elimina último elemento de una lista
                | pop_front                         # Elimina primer elemento de una lista

<op_binario> ::=  +
                | -
                | *
                | /
                | %
                | ^
                | ==
                | !=
                | >
                | >=
                | <
                | <=
                | and
                | or
                | xor
                | push_back                         # Inserta elemento al final de la lista
                | push_front                        # Inserta elemento al principio de la lista

<constante> ::=   <entero>
                | <flotante>
                | <booleano>
                | <caracter>
                | <literal_lista>
                | <cadena>

<entero> ::= <digito> <entero>
            | <digito>

<flotante> ::= <entero> . <entero>
            | . <entero>

<caracter> ::= '<Cualquier caracter ASCII>'

<booleano> ::=    true
                | false

<lista> ::= [ <lista_expresiones> ]
<lista_expresiones> ::= <expresion>, <lista_expresiones> | <expresion> |

<cadena> ::= "<Cadena con cualquier caracter ASCII>"

<funcion> ::= <id> (<lista_expresiones>)

```


## Tabla de tokens

| Nombre del token | Expresión regular | Código del token | Atributos |
|------------------|-------------------------------------------------|------------------|---------------------------------------------------------|
| INICIOBLOQUE  | "{" | 257 | |
| FINBLOQUE  | "}" | 258 | |
| VAR      | "var" | 259 | |
| PRIMITIVO | "int" \| "float" \| "char" \| "bool" \| "string" | 260 | 0: int 1: float 2: char 3: bool 4: string|
| ID         | [a-z\|A-Z][a-z\|A-Z\|0-9\|_]* | 261 | |
| PARIZQ     | "(" | 262 | |
| PARDER     | ")" | 263 | |
| PYC        | ";" | 264 | |
| INPUT        | "input" | 265 | |
| OUTPUT       | "output" | 266 | |
| RETURN     | "return" | 268 | |
| OPUNARIO   | "!" \| "#" \| "?" \| "+" \| "-" | 270 | 0: ! 1: # 2: ? 3: + 4: - |
| OPBIN      | "*" \| "/" \| "%" \| "**" \| "==" \| "!=" \| "&&" \| "\|\|" \| "<" \| ">" \| "<=" \| ">=" \| "--" | 269 | 0: * 1: / 2: % 3: ** 4: == 5: != 6: && 7: \|\| 8: < 9: > 10: <= 11: >= 12: -- |
| AT         | "@"   | 271 | |
| MASMAS     | "++"  | 272 | |
| BINYUN     | "+" \| "-" | 273 | 0: + 1: - |
| CONST      | ([0-9]+) \| ([0-9]*\.[0-9]*) \| ("true" \| "false") \| \'[^\']\'  | 274 | 0: int 1: float 2: bool 3: char |
| ASIGN      | "=" | 275 | |
| COMA       | "," | 276 | |
| MAIN       | "main" | 277 | |
| DO         | "do" | 278 | |
| UNTIL      | "until" | 279 | |
| IF         | "if" | 280 | |
| WHILE      | "while" | 281 | |
| ELSE       | "else" | 282 | |
| CORIZQ     | "[" | 283 | |
| CORDER     | "]" | 284 | |
| DOLLAR     | "$"   | 285 | |
| SHIFT      | "<<" | ">>" | 286 | 0: << 1: >> |